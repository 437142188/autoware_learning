# 动态规划浅谈

（参考https://blog.csdn.net/redbloud/article/details/1947342）

动态规划（ dynamic programming ）算法是解决多阶段决策过程最优化问题的一种常用方法，难度比较大，技巧性也很强。利用动态规划算法，
可以优雅而高效地解决很多贪婪算法或分治算法不能解决的问题。动态规划算法的基本思想是：将待求解的问题分解成若干个相互联系的子问题，
先求解子问题，然后从这些子问题的解得到原问题的解；对于重复出现的子问题，只在第一次遇到的时候对它进行求解，并把答案保存起来，
让以后再次遇到时直接引用答案，不必重新求解。动态规划算法将问题的解决方案视为一系列决策的结果，与贪婪算法不同的是，在贪婪算法中，
每采用一次贪婪准则，便做出一个不可撤回的决策；而在动态规划算法中，还要考察每个最优决策序列中是否包含一个最优决策子序列，即问题是否具有最优子结构性质。

动态规划算法的有效性依赖于待求解问题本身具有的两个重要性质：最优子结构性质和子问题重叠性质。

1 、最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索

2 、子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简 单地查看一下结果，从而获得较高的解题效率

# 动态规划，Dijkstra算法，A*算法的比较
（参考https://blog.csdn.net/z363115269/article/details/16370227）

动态规划，Dijkstra算法，A*算法的框架是相同的，不同点仅在于“推进点的选取”和“算法终止条件”。
一，动态规划：（参见http://blog.csdn.net/iwantnon/archive/2009/07/07/4329269.aspx ）
推进点选取：
（1），在粗犷的动态规划算法中：
根本不进行选择，而是对所有已存在节点全部推进一遍。这可能造成如下两点浪费：
[1]，重复推进：对某点v已经作了推进，而下一次在其valu值没有发生更改的情况下又一次对它进行推进，显然这第二次推进得不到任何新东西，所以是白费的。
[2]，推进失效：对某点v作了推进以后，又对点u作推进，而u恰好将点v的valu值刷新，于是当初对点v所作的推进失效（应该用点v的新valu值重新推进）。
（2），在带open标记的动态规划算法中：
对点v进行推进后将其关闭（令v.open=false），由于在选择推进点时只从处于开启状态的点中选，这样就避免了重复推进v点，除非v点valu值被刷新而再次变为开启(v.open=true)状态。即解决了”重复推进“问题，但并没有解决”推进失效“问题。
终止条件：
无论是在粗犷动态规划算法还是在带open标记的动态规划算法中，为了保证得到终点的最优值都必须“充分推进”--即推进|V|-1次。
二，Dijkstra算法：（参见：http://blog.csdn.net/iwantnon/archive/2009/07/07/4329316.aspx ）
推进点选取：
dijkstra 算法建立在带open标记的动态规划算法之上，但在选取推进点时只选取valu值已达终态的点v（称为"极元"）。由于v的valu值已达终态，所以它不 可能再被其它点刷新，这样就避免了“推进失效”。那么，什么样的点可以作为“极元”呢？极元是否存在及如何构造，是要根据具体问题来分析的，例如：
（1），在"非负权值最短路径"问题中，dis最小的点v就可以取作"极元"，原因是由于所有权值非负，所以其它点推进后dis值会更加大于v的dis值，所以不可能将v刷新。
（2），再如“促销组合”问题中（注），可以状态坐标距st.loc欧氏距离（或曼哈顿距离）最小的状态点v为“极元”，原因是其它点推进后其距st.loc的欧氏距离（或曼哈顿距离）定会进一步增大，从而不可能刷新v点。
（3），再如在"最优排列问题"(例如”旅行商问题“和"工序问题")中，我们可以取已用过的物件集S中物件可个最少的状态点v作为"极元"，原因是其它所有状态点推进后物件集必将进一步扩大，从而不可能刷到v点。
由此可见，“极元”的构造往往依赖于推进过程中某个特征量的单调性。
终止条件： 由 于dijkstra算法中极小元在每次推进后被关闭，并且由于其valu值已达终态，所以不会再被刷新，因此不会被再次开启。也就是说：dijkstra 算法中任何时刻open=false的点都是valu已达终态的点。所以一旦ed.open==false，则可终止程序。这个在某些情况下与动态规划中 必须推进满|V|-1次相比要节约。

注：促销组合问题：
1),min型：有a,b,c三种商品，1a=3元，1b=2元，1c=4元。另提供下列组合：1a+1b=4元，1a+2b+1c=9元，1b+1c=5元。现要买8a+9b+9c，问最少花多少钱？
2),max型：有a,b,c三种商品，买1a给3个赠品，买1b给2个赠品，买1c给4个赠品。另提供下列组合：买1a+1b给8个赠品，买1a+2b+1c给13个赠品，买1b+1c给7个赠品。现要买8a+9b+9c，问最多可得赠品多少个？
三，A*算法：（参见：http://blog.csdn.net/iwantnon/archive/2009/07/07/4329286.aspx ）
推进点选取：
A*算法也是每次只推进一个点，但它是选取当前评价值（注1）最好的点。
由于评价值最好的点未必是极元，所以A*算法存在“推进失效”，不过只要推进的次数足够多（例如推进到所有节点都关闭），显然A*算法能得到最优解。
不过A*算法的目的是：较快地（推进次数较少）得到比较满意的结果。因此往往类似于dijkstra算法，推进到ed.open=false时就结程序（注2）。由于A*算法不能像dijkstra算法那样保证处于关闭状态的节点都已达终态，所以得到近似最优解。
注1：评价值=costed+willcost(或者wined+willwin)，其中costed(或wined)即为当前valu值，而willcost(或willwin)则需要估计来确定。
注2：如果是在所有节点都关闭时结束，则状态空间将包含所有状态，故空间复杂度与动态规划相同（因而高于dijkstra算法）。又由于存在“推进失效”，所以时间复杂度也比dijkstra算法高。
终止条件：
上面已提到，A*算法往往取ed.open=false时终止。

进一步总结如下：
1、动态规划，推进点要么遍历，要么在open列表中选择，每次对多个进行更新，推进回合数是固定的|V|-1，可能使close重新变为open，是全局最优的
2、Dijkstra，推进点在极元中选取，每次会选取多个极元进行更新，推进回合数取决于open列表中是否有元素，是全局最优的
3、A*，推进点每次只更新一个，选取那个取决于启发函数，推进回合数取决于open列表中是否有元素，由于启发的点未必是极元，因此是局部最优的
